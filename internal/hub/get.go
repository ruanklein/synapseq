//go:build !nohub

/*
 * SynapSeq - Synapse-Sequenced Brainwave Generator
 * https://synapseq.org
 *
 * Copyright (c) 2025-2026 SynapSeq Foundation
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2.
 * See the file COPYING.txt for details.
 */

package hub

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"

	t "github.com/synapseq-foundation/synapseq/v3/internal/types"
)

// HubGet retrieves a sequence by its ID from the Hub
func HubGet(sequenceID string) (*t.HubEntry, error) {
	manifest, err := GetManifest()
	if err != nil {
		return nil, err
	}

	var entry *t.HubEntry
	for _, e := range manifest.Entries {
		if e.ID == sequenceID {
			entry = &e
			break
		}
	}

	return entry, nil
}

// HubDownload downloads a sequence and its dependencies from the Hub
func HubDownload(entry *t.HubEntry, action t.HubActionTracking, wg *sync.WaitGroup) (string, error) {
	if entry == nil {
		return "", fmt.Errorf("hub entry is nil")
	}

	cache, err := GetCacheDir()
	if err != nil {
		return "", err
	}

	path := filepath.Join(cache, strings.TrimSuffix(entry.Path, ".spsq"))
	if err := os.MkdirAll(path, 0755); err != nil {
		return "", err
	}

	sequencePath := filepath.Join(path, entry.Name+".spsq")
	if _, err := os.Stat(sequencePath); err == nil {
		return sequencePath, nil
	}

	for _, dep := range entry.Dependencies {
		var depPath string
		if dep.Type == t.HubDependencyTypeBackground {
			depPath = filepath.Join(path, dep.Name+".wav")
		} else {
			depPath = filepath.Join(path, dep.Name+".spsq")
		}

		resp, err := http.Get(dep.DownloadUrl)
		if err != nil {
			return "", fmt.Errorf("error downloading dependency %s: %v", dep.Name, err)
		}
		defer resp.Body.Close()

		data, err := io.ReadAll(resp.Body)
		if err != nil {
			return "", fmt.Errorf("error reading dependency %s: %v", dep.Name, err)
		}

		if err = os.WriteFile(depPath, data, 0644); err != nil {
			return "", fmt.Errorf("error saving dependency %s: %v", dep.Name, err)
		}
	}

	resp, err := http.Get(entry.DownloadUrl)
	if err != nil {
		return "", fmt.Errorf("error downloading sequence %s: %v", entry.Name, err)
	}
	defer resp.Body.Close()

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("error reading sequence %s: %v", entry.Name, err)
	}

	if err = os.WriteFile(sequencePath, data, 0644); err != nil {
		return "", fmt.Errorf("error saving sequence %s: %v", entry.Name, err)
	}

	if wg != nil {
		wg.Go(func() {
			// Track the download event
			TrackDownload(entry.ID, action)
		})
	}

	return sequencePath, nil
}
